- registry
    - [rpc] register
    - [rpc] unregister
        - explicit
        - network failiure
        - timeouts

    * maybe cache contracts?

- service
    - [fn] register(book: node_id_t, id: id_t, info: reginfo_t): ok_t
    - [fn] set_contract(contract: contract_t): ok_t

    - [rpc] get_contract(): contract_t
    - [rpc] subscribe_contract(): sub_t<contract_t>
    - [rpc] call(args_t): value_t

- client
    - [fn] construct(target: pid_t)
    - [fn] get_contract(): contract_t
    - [fn] subscribe_contract(): sub_t<contract_t>
    - [fn] call(method: method_path_t, args: args_t): value_t

- elixir code:

defcontract do
    prop "device_type" "light_controller"
    prop "description" "Light controller"
    prop "human_name" "Lamp in living room"
    subcontract "controls" do   # syntax sugar for prop "controls" (defcontract do ...
        prop "description" "controls"
        subcontract "lightness" do
            prop "description" "Lightness"
            method "get" type{() -> int} do
                return foo
            end
            method "set" type{(int) -> ()} %{min: 0, max: 65535} do
                do stuff
            end
            method "subscribe" type{() -> chan<int>} do
                return newchan bla
            end
        end
    end
end

- todo:
    - expose contracts via json (figure out how to serialise them)
    - implement type casts
    - persistent register, which monitors the state of the registry and re-registers if needed (or sends a message when it goes down)
    - subscriptions
    - tcp client api
    - websocket client api
    - ui