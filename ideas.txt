- elixir code:

defcontract do
    prop "device_type" "light_controller"
    prop "description" "Light controller"
    prop "human_name" "Lamp in living room"
    subcontract "controls" do   # syntax sugar for prop "controls" (defcontract do ...
        prop "description" "controls"
        subcontract "lightness" do
            prop "description" "Lightness"
            method "get" type{() -> int} do
                return foo
            end
            method "set" type{(int) -> ()} %{min: 0, max: 65535} do
                do stuff
            end
            method "subscribe" type{() -> chan<int>} do
                return newchan bla
            end
        end
    end
end

- todo:
    - implement "subscribe" in cache which subscribes to a subcontract
        - similar semantics to "get" which gets a subcontract from the cache
        - user calls attach(cache, root, [foo, bar, baz])
        - if foo was missing, wait for it to appear in root's contract
        - if bar was missing, wait for it to appear in foo's contract
        - if baz was missing, wait for it to appear in bar's contract

    - implement pestering call in cache
        - user calls pester(root, [foo, bar, baz], arg, fun)
        - contracts of foo, bar and baz are attached and baz is called
        - fun is called with the result from baz
        - easily implemented by using subscribe

    - implement persistent call
        - that would be a one liner using the pestering call and recursive fun


    - notify channel subscribers when channel dies (maybe also subscribe_link)

    - persistent register (register_link?)

    - make channels die when their parent exits normally

    - prettification
        - behaviours for services
        - docs everywhere
        - better error handling in mesh.ex

- roadmap:
    - construct unified cache, remove unsafe calls from everywhere
    - api refactoring
    - prettify code
