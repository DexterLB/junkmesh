***** POTOO 2 DRAFT *****
*************************

- a protocol over mqtt, not software
- specify a standard for types and contracts
- services connect and publish their contract with retain + lwt deletion
- light (written in something like go?) websocket <-> mqtt gateway
- 3 basic types in contracts: constants, values, callables
- each value has a topic on which updates will be sent (with retain)
- values with a "set" callable under them are properties
- each callable has a topic with 2 subtopics: call and reply
- special "void" return type which means the callable won't reply
- maybe use a binary format for messages which is easily serialisable from embedded targets (msgpack?)
- BONUS: mqtt transports (mosquitto) already have websocket implementations.
  thus, a jabbascript gui could be built directly without requiring any
  server code.

- 2 possible approaches:
    * simple approach
        - no registries
        - no paths, handles or names other than topics themselves
        - all contracts live in a separate root, e.g. _contract/<topic> is the contract
          for the service which lives under <topic>
        - contract structure represents topic structure
        - a service publishes its contract with retain under topic/contract
        - child services simply have this topic as a prefix to theirs.
        - to subscribe to an entire subtree, just subscribe to _contract/<root>/#
    * potoo1-ish approach
        - have registries as before
        - paths in topics don't really matter.
        - every value has a topic on which updates will be sent (with retain)
        - every callable has a call topic and reply topic
        - additional type (delegate) which holds the contract topic of the child

*************************

- elixir code:

defcontract do
    prop "device_type" "light_controller"
    prop "description" "Light controller"
    prop "human_name" "Lamp in living room"
    subcontract "controls" do   # syntax sugar for prop "controls" (defcontract do ...
        prop "description" "controls"
        subcontract "lightness" do
            prop "description" "Lightness"
            method "get" type{() -> int} do
                return foo
            end
            method "set" type{(int) -> ()} %{min: 0, max: 65535} do
                do stuff
            end
            method "subscribe" type{() -> chan<int>} do
                return newchan bla
            end
        end
    end
end

- todo:
    - fix cache subscribe() to work for dead targets
        - use a timeout

    - implement pestering call in cache
        - user calls pester(root, [foo, bar, baz], arg, fun)
        - contracts of foo, bar and baz are attached and baz is called
        - fun is called with the result from baz
        - easily implemented by using subscribe

    - implement persistent call
        - that would be a one liner using the pestering call and recursive fun

    - better death support for channels
        - subscribe_link
        - way to notify subscribers when channel dies
        - some sort of one-way link (way to kill subscriber when channel dies but
          not kill channel when subscriber dies)
        - go through code and see which uses of Channel.start_link are legit
            - some channels are shared between many subscribers and should
              be started with start_link and subscribed with subscribe
            - others are attached to a producing process and have to be started
              with start, linked to the producer and subscribed with subscribe_link
            - maybe set this upon channel creation so subscribers only call
              subscribe()? (bad idea)

    - persistent register (register_link?), but one-way (no need to kill the registry)

    - prettification
        - behaviours for services
        - docs everywhere
        - better error handling in potoo.ex

- roadmap:
    - construct unified cache, remove unsafe calls from everywhere
    - api refactoring
    - prettify code
