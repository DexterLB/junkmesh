- elixir code:

defcontract do
    prop "device_type" "light_controller"
    prop "description" "Light controller"
    prop "human_name" "Lamp in living room"
    subcontract "controls" do   # syntax sugar for prop "controls" (defcontract do ...
        prop "description" "controls"
        subcontract "lightness" do
            prop "description" "Lightness"
            method "get" type{() -> int} do
                return foo
            end
            method "set" type{(int) -> ()} %{min: 0, max: 65535} do
                do stuff
            end
            method "subscribe" type{() -> chan<int>} do
                return newchan bla
            end
        end
    end
end

- todo:
    - notify channel subscribers when channel dies (maybe also subscribe_link)
    - persistent register (register_link?)
    - a unified cache which allows calling by path, keeps contracts
      in state and automatically drops items
        - persistent subscribe (by path from unified cache)
        - cache subscribes to all contracts, updates them on the fly

    - fix json api:
        - call unjsonify in all calls before performing the api call
        - (side effect of ^) use channels instead of direct channel pids
        * hold off for now, since this will break clients
    - make channels die when their parent exits normally
    - prettification
        - behaviours for services
        - docs everywhere
        - normal error handling in mesh.ex
    - make functions contain a pid. populate it when getting contracts, if not
      already present. That allows for delegated functions and completes the
      duality with channels.

- roadmap:
    - construct unified cache, remove unsafe calls from everywhere
    - api refactoring
    - prettify code
